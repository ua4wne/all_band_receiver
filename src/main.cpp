// =============================== ПОДКЛЮЧЕНИЕ БИБЛИОТЕК ===========================================================================

#include <rotary.h>                  // Подключаем библиотеку, следящую за положением энкодера
#include <si5351.h>                  // Подключаем библиотеку, управляющую работой генератора SI5351
#include <LiquidCrystal.h>           // Подключаем библиотеку, управляющую работой дисплея
#include <Wire.h>                    // Подключаем библиотеку, управляющую работой шины I2C (связь SI5351 c Arduino)
#include <main.h>                    // Определение функций

// =============================== ОПРЕДЕЛЕНИЕ ИМЕН ПЕРЕМЕННЫХ И НАЗНАЧЕНИЕ ВЫВОДОВ МИКРОКОНТРОЛЛЕРА ===============================

#define F_MIN        150000ULL       // Переменная F_MIN (нижний предел частоты - 150 кГц)
#define F_MAX        146000000ULL    // Переменная F_MAX (верхний предел частоты - 146 МГц)

uint8_t ENCODER_A = 2;               // Переменная ENCODER_A (на 2-м выводе - контакт A энкодера)
uint8_t ENCODER_B = 3;               // Переменная ENCODER_B (на 3-м выводе - контакт В энкодера)
uint8_t LCD_D4 = 4;                  // Переменная LCD_D4 (на 4-м выводе - контакт D4 дисплея)
uint8_t LCD_D5 = 5;                  // Переменная LCD_D5 (на 5-м выводе - контакт D5 дисплея)
uint8_t LCD_D6 = 6;                  // Переменная LCD_D6 (на 6-м выводе - контакт D6 дисплея)
uint8_t LCD_D7 = 7;                  // Переменная LCD_D7 (на 7-м выводе - контакт D7 дисплея)
uint8_t LCD_RS = 8;                  // Переменная LCD_RS (на 8-м выводе - контакт RS дисплея) 
uint8_t LCD_E  = 9;                  // Переменная LCD_E (на 9-м выводе - контакт E дисплея)  
uint8_t ATT = 10;                    // включение \ отключение аттенюатора
uint8_t AMP = 13;                    // включение \ отключение УВЧ
uint8_t HF_UNF = 11;                 // Переменная HPF (на 11-м выводе - обмотка реле, включающего ФВЧ (High-Pass Filter)
uint8_t IN_A = 14;                   // Вход коммутации А
uint8_t IN_B = 15;                   // Вход коммутации В  
uint8_t pinIn = A6;                    // Переменная pinIn (вывод А6 - в режиме АЦП для обработки нажатия кнопок)
uint8_t Pressed_Key = 0;               // Переменная Pressed_Key, указывает номер нажатой кнопки. Если 0 - кнопки не нажаты
uint8_t count_mode = 1;                // Число нажатий кнопки выбора модуляции
uint8_t count_regime = 1;              // число нажатий кнопки выбора режима работы
//uint8_t mod_Key = 1;                   // Переменная, указывающая, какой демодулятор использовать: SSB/AM/FM (для кнопки MOD)
uint8_t mod_Auto = 1;                  // Переменная, указывающая, какой демодулятор использовать: SSB/AM/FM (в автоматическом режиме)
uint8_t band = 0;                      // Переменная, указывающая, в каком диапазоне осуществляется настройка в текущий момент
uint8_t band_mod = 0;                  // Переменная, указывающая, какой вид демодулятора предпочтительно использовать в текущем диапазоне
uint8_t step = 4;                      // Переменная, определяющая шаг перестройки частоты: 1 Гц...10 МГц (при включении шаг - 1кГц)
//boolean key4 = 0;
  
volatile uint64_t IF = 45021700ULL;  // Переменная,значение первой промежуточной частоты (45 МГц)
volatile uint64_t F_display = 7100000ULL;   // Переменная,отображаемая на дисплее частота настройки (при включении - 7,100 МГц)
volatile uint64_t F_Out = 0;         // Переменная,частота на выходе синтезатора
volatile uint64_t radix = 1000;      // Переменная, шаг перестройки частоты (по умолчанию при старте = 1 кГц)
bool changed_f = false;           // Переменная changed_f, отражающая факт изменения частоты настройки (1 - частота изменилась)
bool changed_mod = false;         // Переменная changed_mod, отражающая факт смены демодулятора (1 - демодулятор переключен)
bool LPF_HPF = false;             // Переменная LPF_HPF (0 - включен ФНЧ (LPF); 1 - включен ФВЧ (HPF))

enum {NONE, SSB, AM, FM, AUTO} mod_Key;    // Переменная, указывающая, какой демодулятор использовать: SSB/AM/FM (для кнопки MOD)
enum {OFF=1, AMP_ON, ATT_OFF, ATT_ON} regime; // Переменная, определяющая режим работы: УВЧ/аттенюатор/обход (для кнопки AMP/ATT)

// =============================== БИБЛИОТЕКИ ======================================================================================= 
 
LiquidCrystal lcd(LCD_RS, LCD_E, LCD_D4, LCD_D5, LCD_D6, LCD_D7); // Подключаем библиотеку, управляющую работой дисплея. 
                                                                    // Указываем имена переменных, отвечающих за работу дисплея.
Si5351 si5351;                                                    // Подключаем библиотеку, управляющую работой генератора SI5351
Rotary r = Rotary(ENCODER_A, ENCODER_B);                          // Подключаем библиотеку, следящую за энкодером. 
                                                                    // Указываем имена переменных, изменяющихся в зависимости
                                                                    // от изменения положения ротора энкодера.

// =============================== ФУНКЦИИ ==========================================================================================

/*****************************************************************/
/* Обработчик отслеживания положения энкодера по прерыванию      */
/* encoder frequency change                                      */
/*****************************************************************/
ISR(PCINT2_vect)                
{                                      // Начало обработчика отслеживания положения энкодера по прерыванию
    unsigned char result = r.process();  // Объявление переменной result и присвоение ей значения переменной r.process
    if (result == DIR_CW)                // Если переменная result равна значению DIR_CW ...
        set_frequency(1);                  // переходим к исполнению Функции set_frequency с аргументом "1"
    else if (result == DIR_CCW)          // В противном случае, если переменная result равна значению DIR_CCW ...
        set_frequency(-1);                 // переходим к исполнению Функции set_frequency с аргументом "-1"
}                                      // Окончание обработчика отслеживания положения энкодера по прерыванию

/**************************************************************************************/
/* Функция изменения частоты валкодером                                               */
/* если переменная dir = 1, значит частоту увеличиваем (Increment; энкодер - вправо)  */
/* если переменная dir = -1, значит частоту уменьшаем (Decrement;  энкодер - влево)   */
/**************************************************************************************/
void set_frequency(short dir)
{                                      // Начало функции set_frequency
    if (dir == 1)                        // если энкодер вращают вправо ...
        F_display += radix;                // увеличить отображаемую частоту (F_display) на значение шага (radix)
    if (dir == -1)                       // если энкодер вращают влево ...
        F_display -= radix;                // уменьшить отображаемую частоту (F_display) на значение шага (radix)
    if(F_display > F_MAX)                // если отображаемая частота (F_display) превысила максимальную (F_MAX) ...
        F_display = F_MAX;                // остановиться на максимальной частоте (F_MAX)
    if(F_display < F_MIN)                // если отображаемая частота (F_display) меньше минимальной (F_MIN) ...  
        F_display = F_MIN;                // остановиться на минимальной частоте (F_MIN) 
    changed_f = 1;                       // присвоить переменной changed_f (частота изменилась) значение "1"
}                                      // Окончание функции set_frequency

/**************************************************************************************/
/* Функция установки вида модуляции вручную                                           */
/**************************************************************************************/
void set_mod_Key()
{                                     // Начало функции установки вида модуляции вручную set_mod_Key
    if(mod_Key == SSB)            // Если кнопка MOD нажата один раз - включить демодулятор SSB:
    { 
        digitalWrite(IN_A, HIGH);       // установить "1" на выводе 14 (вход А платы коммутации)
        digitalWrite(IN_B, HIGH);       // установить "1" на выводе 15 (вход В платы коммутации)
        lcd.setCursor(0, 1);            // установить курсор на дисплее: нулевой столбец, первая(нижняя)строка
        lcd.print("SSB ");              // вывести текст: "SSB_"
    } 
    if(mod_Key == AM)                  // Если кнопка MOD нажата два раза - включить демодулятор AM:
    { 
        digitalWrite(IN_A, HIGH);       // установить "1" на выводе 14 (вход А платы коммутации)
        digitalWrite(IN_B, LOW);        // установить "0" на выводе 15 (вход В платы коммутации)
        lcd.setCursor(0, 1);            // установить курсор на дисплее: нулевой столбец, первая(нижняя)строка
        lcd.print("AM  ");              // вывести текст: "АМ__"
    } 
    if(mod_Key == FM)                  // Если кнопка MOD нажата три раза - включить демодулятор FM:
    { 
        digitalWrite(IN_A, LOW);        // установить "0" на выводе 14 (вход А платы коммутации)
        digitalWrite(IN_B, HIGH);       // установить "1" на выводе 15 (вход В платы коммутации)
        lcd.setCursor(0, 1);            // установить курсор на дисплее: нулевой столбец, первая(нижняя)строка
        lcd.print("FM  ");              // вывести текст: "FМ__"         
    }   
}                                     // Окончание функции установки вида модуляции вручную set_mod_Key


/**************************************************************************************/
/* Функция установки вида модуляции в автоматическом режиме                           */
/**************************************************************************************/
void set_mod_Auto()
{                                    // Начало функции установки вида модуляции в автоматическом режиме set_mod_Auto
    if(mod_Auto == NONE)              // Если переменная mod_Auto равна нулю - отключить все входы демодуляторов:          
    {
        digitalWrite(IN_A, LOW);       // установить "0" на выводе 14 (вход А платы коммутации)
        digitalWrite(IN_B, LOW);       // установить "0" на выводе 15 (вход В платы коммутации)
        lcd.setCursor(0, 1);           // установить курсор на дисплее: нулевой столбец, первая(нижняя)строка
        lcd.print("OFF ");             // вывести текст: "OFF_"
    }
    if(mod_Auto == SSB)               // Если переменная mod_Auto равна единице - включить демодулятор SSB:
    { 
        digitalWrite(IN_A, HIGH);      // установить "1" на выводе 14 (вход А платы коммутации)
        digitalWrite(IN_B, HIGH);      // установить "1" на выводе 15 (вход В платы коммутации)
        lcd.setCursor(0, 1);           // установить курсор на дисплее: нулевой столбец, первая(нижняя)строка
        lcd.print("SSB ");             // вывести текст: "SSB_"    
    } 
    if(mod_Auto == AM)                // Если переменная mod_Auto равна двум - включить демодулятор AM:
    { 
        digitalWrite(IN_A, HIGH);      // установить "1" на выводе 14 (вход А платы коммутации)
        digitalWrite(IN_B, LOW);       // установить "0" на выводе 15 (вход В платы коммутации)
        lcd.setCursor(0, 1);           // установить курсор на дисплее: нулевой столбец, первая(нижняя)строка
        lcd.print("AM  ");             // вывести текст: "АМ__"        
    } 
    if(mod_Auto == FM)                // Если переменная mod_Auto равна трем - включить демодулятор FM:
    { 
        digitalWrite(IN_A, LOW);          // установить "0" на выводе 14 (вход А платы коммутации)
        digitalWrite(IN_B, HIGH);         // установить "1" на выводе 15 (вход В платы коммутации)
        lcd.setCursor(0, 1);           // установить курсор на дисплее: нулевой столбец, первая(нижняя)строка
        lcd.print("FM  ");             // вывести текст: "FМ__"       
    }
}                                    // Окончание функции установки вида модуляции в автоматическом режиме set_mod_Auto


/**************************************************************************************/
/* Функция установки режима работы входа (УВЧ/АТТ/Обход)                              */
/**************************************************************************************/
void set_regime()
{                                   // Начало функции установки режима работы входа set_regim
    if(regime == OFF)              // Если кнопкой ATT/AMP выбран первый режим (обход УВЧ и АТТ), то ...
    {
        lcd.setCursor(6, 1);          // установить курсор на дисплее: шестой столбец, первая(нижняя)строка
        lcd.print("   ");             // вывести текст: "___" (три пробела) 
        digitalWrite(ATT, LOW);       // установить вывод 10 в ноль (включаем реле "ATT OFF")
        digitalWrite(AMP,LOW);        // установить вывод 13 в ноль (снимаем напряжение с реле "AMP OFF")   
    } 
    if(regime == AMP_ON)            // Если кнопкой ATT/AMP выбран второй режим (вкл. УВЧ), то ...
    { 
        lcd.setCursor(6, 1);          // установить курсор на дисплее: шестой столбец, первая(нижняя)строка
        lcd.print("AMP");             // вывести текст: "AMP" 
        digitalWrite(AMP, HIGH);      // установить вывод 13 в единицу (включаем реле "AMP ON")
        digitalWrite(ATT, LOW);       // установить вывод 12 в ноль (снимаем напряжение с реле "ATT OFF")   
    } 
    if(regime == ATT_OFF)            // Если кнопкой ATT/AMP выбран третий режим (обход УВЧ и АТТ), то ...
    {
        lcd.setCursor(6, 1);          // установить курсор на дисплее: шестой столбец, первая(нижняя)строка
        lcd.print("   ");             // вывести текст: "___" (три пробела) 
        digitalWrite(ATT, LOW);       // установить вывод 10 в ноль (снимаем напряжение с реле "ATT OFF")
        digitalWrite(AMP, LOW);       // установить вывод 13 в ноль (снимаем напряжение с реле "AMP OFF")   
    } 
    if(regime == ATT_ON)            // Если кнопкой ATT/AMP выбран четвертый режим (вкл. АТТ), то ...         
    { 
        lcd.setCursor(6, 1);          // установить курсор на дисплее: шестой столбец, первая(нижняя)строка
        lcd.print("ATT");             // вывести текст: "ATT" 
        digitalWrite(ATT, HIGH);      // установить вывод 10 в единицу (включаем реле "ATT ON")
        digitalWrite(AMP, LOW);       // установить вывод 16 в ноль (снимаем напряжение с реле "AMP OFF")              
    } 
}                                   // Окончание функции установки режима работы входа set_regim

/**********************************************/
/* Функция отображения установленной частоты  */
/**********************************************/
void display_frequency()            // Объявление функции display_frequency
{                                   // Начало функции display_frequency
    uint32_t f;                       // Объявление вспомогательной целой беззнаковой переменной f
    lcd.setCursor(5, 0);              // Устанавливаем курсор в пятый столбец нулевой (верхней) строки
    f = F_display / 1000000;          // Делим значение отображаемой частоты на миллион, получившееся значение присваиваем переменной f
    if (f < 100)                      // Если f (количество МегаГерц) меньше ста ...
        lcd.print(' ');                 // отображаем на индикаторе пробел (в 5-м столбце)
    if (f < 10)                       // Если f (количество МегаГерц) меньше десяти...
        lcd.print(' ');                 // отображаем на индикаторе два пробела (в 5-м и 6-м столбцах)
    lcd.print(f);                     // Отображаем значение переменной f 
    lcd.print('.');                   // После f (в седьмом столбце) отображаем разделитель разрядов (точку)
    f = (F_display % 1000000) / 1000; // Присваиваем переменной f одну тысячную остатка от деления отображаемой частоты на миллион (вычисляем сотни килоГерц)
    if (f < 100)                      // Если получившееся значение f меньше сотни...
        lcd.print('0');                 // после разделителя разрядов (в восьмом столбце) отображаем "0"
    if (f < 10)                       // Если f меньше десяти...
        lcd.print('0');                 // следом (в девятом столбце) пишем "0"
    lcd.print(f);                     // Отображаем значение f, причем, если не выполнено два предыдущих условия - начиная с 8-го столбца
    lcd.print('.');                   // Ставим новый разделитель разрядов (в 11-м столбце)
    f = F_display % 1000;             // Присваиваем переменной f остаток от деления отображаемой частоты на тысячу (вычисляем сотни Герц)
    if (f < 100)                      // Если f меньше сотни...
        lcd.print('0');                 // Заполняем разряд, соответствующий сотне Герц нулем (12-й столбец)
    if (f < 10)                       // Если f меньше десяти...
        lcd.print('0');                 // заполняем разряд, соответствующий десяткам Герц нулем (13-й столбец)
    lcd.print(f);                     // отображаем значение f, причем, если не выполнено два предыдущих условия - начиная с 12-го столбца
}                                   // Окончание функции display_frequency

/**********************************************/
/* Функция установки шага изменения частоты   */
/**********************************************/
void set_step()                     // Объявление функции установки шага изменения частоты set_step
{
    if(step==1)                         // Если переменная step равна единице, ...
    { 
        radix = 1;                     // переменной radix присвоить значение "1" (шаг настройки - 1 Гц)
        display_radix();               // Вызвать функцию отображения шага изменения частоты display_radix
    } 
    if(step==2)
    { 
        radix = 10;                    // переменной radix присвоить значение "10" (шаг настройки - 10 Гц)
        display_radix();               // Вызвать функцию отображения шага изменения частоты display_radix 
    } 
    if(step==3)
    { 
        radix = 100;                   // переменной radix присвоить значение "100" (шаг настройки - 100 Гц)
        display_radix();               // Вызвать функцию отображения шага изменения частоты display_radix 
    } 
    if(step==4)
    { 
        radix = 1000;                  // переменной radix присвоить значение "1000" (шаг настройки - 1 кГц)
        display_radix();               // Вызвать функцию отображения шага изменения частоты display_radix
    } 
    if(step==5)
    { 
        radix = 10000;                 // переменной radix присвоить значение "10000" (шаг настройки - 10 кГц)
        display_radix();               // Вызвать функцию отображения шага изменения частоты display_radix 
    } 
    if(step==6)
    { 
        radix = 100000;                // переменной radix присвоить значение "10 000" (шаг настройки - 100 кГц)
        display_radix();               // Вызвать функцию отображения шага изменения частоты display_radix
    } 
    if(step==7)
    { 
        radix = 1000000;               // переменной radix присвоить значение "1000000" (шаг настройки - 1 МГц)
        display_radix();               // Вызвать функцию отображения шага изменения частоты display_radix
    } 
    if(step==8)
    { 
        radix = 10000000;              // переменной radix присвоить значение "10000000" (шаг настройки - 10 МГц)
        display_radix();               // Вызвать функцию отображения шага изменения частоты display_radix
    }  
}                                   // Окончание функции установки шага изменения частоты set_step

/**********************************************/
/* Функция отображения шага изменения частоты */
/**********************************************/
void display_radix()                // Объявление функции отображения шага изменения частоты display_radix
{                                   // Начало функции display_radix
    lcd.setCursor(10, 1);             // Устанавливаем курсор в 10-й столбец первой (нижней) строки
    switch (radix)                    // Оператор switch сравнивает значение переменной radix с операторами case:
    {                                 // Начало тела оператора switch
        case 1:                         // Переменная radix равна единице (шаг перестройки - 1 Гц)?
        lcd.print("   1");            // Начиная с 10-го столбца отображаем "  1"
        break;                        // Выходим из оператора case 1
        case 10:                        // Переменная radix равна десяти (шаг перестройки - 10 Гц)?
        lcd.print("  10");            // Начиная с 10-го столбца отображаем " 10"
        break;                        // Выходим из оператора case 10
        case 100:                       // Переменная radix равна ста (шаг перестройки - 100 Гц)?
        lcd.print(" 100");            // Начиная с 10-го столбца отображаем "100H"
        break;                        // Выходим из оператора case 100
        case 1000:                      // Переменная radix равна тысяче (шаг перестройки - 1 кГц)?
        lcd.print("  1k");            // Начиная с 10-го столбца отображаем "  1k"
        break;                        // Выходим из оператора case 1000
        case 10000:                     // Переменная radix равна десяти тысячам (шаг перестройки - 10 кГц)?
        lcd.print(" 10k");            // Начиная с 10-го столбца отображаем " 10k"
        break;                        // Выходим из оператора case 10000
        case 100000:                    // Переменная radix равна ста тысячам (шаг перестройки - 100 кГц)?
        lcd.print("100k");            // Начиная с 10-го столбца отображаем "100k"
        break;                        // Выходим из оператора case 100000
        case 1000000:                   // Переменная radix равна миллиону (шаг перестройки - 1 МГц)?
        lcd.print("  1M");            // Начиная с 10-го столбца отображаем "  1M"
        break;                        // Выходим из оператора case 1000000
        case 10000000:                  // Переменная radix равна десяти миллионам (шаг перестройки - 10 МГц)?
        lcd.print(" 10M");            // Начиная с 10-го столбца отображаем " 10M"
        break;                        // Выходим из оператора case 10000000
    }                                 // Окончание тела оператора switch
    lcd.print("Hz");                  // В конце выбранного шага изменения частоты пишем "Hz"
}                                   // Окончание функции display_radix


 
void setup() {                      // Начало функции
    Serial.begin(9600);               // Инициализация  порта монитора и задание скорости передачи данных в бит/c (бод)
    pinMode(pinIn, INPUT);            // Вывод А3 (ему присвоена переменная pinIn) конфигурируем в режим входа для опроса кнопок
    pinMode(ATT, OUTPUT);              // Вывод 10 конфигурируем на выход (для управления реле АТТ ОN)
    //pinMode(12, OUTPUT);              // Вывод 12 конфигурируем на выход (для управления реле АТТ ОFF)
    pinMode(AMP, OUTPUT);              // Вывод 13 конфигурируем на выход (для управления реле AMP ОN)
    pinMode(IN_A, OUTPUT);              // Вывод 14 (A0) конфигурируем на выход (для управления ключом А на плате коммутации)
    pinMode(IN_B, OUTPUT);              // Вывод 15 (A1) конфигурируем на выход (для управления ключом B на плате коммутации)
    //pinMode(16, OUTPUT);              // Вывод 16 (A2) конфигурируем на выход (для управления реле AMP ОFF)
    //pinMode(LPF, OUTPUT);             // Вывод 17 (А3) конфигурируем на выход (для управления реле HF ОN)
    pinMode(HF_UNF, OUTPUT);             // Вывод 11 (D11) конфигурируем на выход (для управления реле UHF ON)
    mod_Key = SSB;
    regime = OFF;

    lcd.begin(16, 2);                 // Указываем параметры дисплея 1602: 16 столбцов, 2 строки
    lcd.clear();                      // Очистка информации, отображаемой на дисплее
    Wire.begin();                     // Задействуем шину I2C для связи с модулем SI5351

    si5351.set_correction(140700, SI5351_PLL_INPUT_XO);    // Вводим калибровочную константу. Для ее получения запускаем скетч "si5351calibration"   
                                        // из папки с примерами библиотеки si5351 и включаем монитор порта(57600 бод).
                                        // На выход генератора CLK0 подключаем частотомер. Отправляя команды через монитор порта 
                                        // (поразрадно, как указано в подсказке, выводимой в мониторе), добиваемся показаний на частотомере 
                                        // ровно 10 000 000 МГц. Значение константы будет выведено в последней строке в мониторе порта.
  
    si5351.init(SI5351_CRYSTAL_LOAD_8PF, 0, 0); // Инициализируем Si5351. Ели в обвязке SI5351используется кварц на 27 МГц, 
                                            // вводим 27000000 вместо значения 0 (0 - значение по умолчанию для кварца 25 МГц).
    
    si5351.set_pll(SI5351_PLL_FIXED, SI5351_PLLA);

    si5351.set_freq((F_display + IF) * SI5351_FREQ_MULT, SI5351_CLK0);

    display_frequency();              // Обращаемся к функции отображения установленной частоты на дисплее
    changed_f = 0;                    // Присваиваем переменной changed_f (частота изменилась) значение "0" 
            
    
    PCICR |= (1 << PCIE2);            // Задействование прерывания для отслеживания состояния энкодера
    PCMSK2 |= (1 << PCINT18) | (1 << PCINT19);
    sei();
    
    display_frequency();              // Обращение к функции отображения установленной частоты на дисплее
    display_radix();                  // Обращение к функции отображения шага перестройки частоты на дисплее
    set_regime();
    set_mod_Key();   
                
    digitalWrite(HF_UNF, LOW);        // Снимаем питание с обмотки реле ФНЧ/ФВЧ        
}

// ========================================== ОСНОВНОЙ ЦИКЛ ==========================================

void loop() 
{                             // Начало основного цикла
                              // Обновление показаний дисплея в случае смены частоты
    if (changed_f)              // Если переменная changed_f (частота изменилась) имеет значение "1", то ...
    {                           // Выполняем инструкции, заключенные в фигурные скобки 

        if (F_display >= 87500000ULL) // Если частота, отображаемая на дисплее больше или равна 80 МГц ...
        {                    // Устанавливаем на выходе синтезатора частоту,соответсвующую разности отображаемой и промежуточной частот
            si5351.set_freq((F_display - IF) * SI5351_FREQ_MULT, SI5351_CLK0);
            display_frequency(); // Обращаемся к функции отображения установленной частоты на дисплее
            changed_f = 0;       // Присваиваем переменной changed_f (частота изменилась) значение "0"

            if (!LPF_HPF)    // Если переменная LPF_HPF имеет значение "0" (включен ФНЧ), то ...    
            { 
                digitalWrite(HF_UNF, HIGH);       // Включаем реле ФНЧ/ФВЧ в режим UHF
                LPF_HPF = true;
            } 
        }                    // Окончание проверки условия (F_display >= 80000000ULL)
        if (F_display < 87500000ULL)  // Если частота, отображаемая на дисплее меньше 80 МГц ...
        {                    // Устанавливаем на выходе синтезатора частоту,соответсвующую сумме отображаемой и промежуточной частот
            si5351.set_freq((F_display + IF) * SI5351_FREQ_MULT, SI5351_CLK0);
            display_frequency(); // Обращаемся к функции отображения установленной частоты на дисплее
            changed_f = 0;       // Присваиваем переменной changed_f (частота изменилась) значение "0"
                
            if (LPF_HPF)    // Если переменная LPF_HPF имеет значение "1" (включен ФВЧ), то ...  
            {
                digitalWrite(HF_UNF, LOW);      // Снимаем питание с обмотки реле
                LPF_HPF = false;
            }
        }                    // Окончание проверки условия (F_display < 90000000ULL)
    }                           // Окончание проверки условия if (changed_f)


    // -------------------------- Обработка нажатия кнопок  --------------------------
    int newPressed_Key = GetPressed_Key();      // Получаем актуальное состояние кнопок с коррекцией дребезга

    if (Pressed_Key != newPressed_Key)          // Если новое значение не совпадает со старым - реагируем на него 
    {                                
        Pressed_Key = newPressed_Key;            // Актуализируем переменную хранения состояния
        if (Pressed_Key > 0)                  // Если значение больше 0, значит кнопка нажата
        {              
    // --------------------------------- Обработка нажатия кнопки MOD ---------------------------------     
            if(Pressed_Key == 1)                      // если нажата кнопка 1 (MOD), то ... 
            {  
                count_mode ++;                     // увеличиваем значение переменной count_mode на единицу
                changed_mod = true;                  // переменной changed_mod присваиваем значение "1" (т.е. демодулятор выбрали вручную)

                switch (count_mode) {
                    case 0:
                        mod_Key = NONE;
                        break;
                    case 1:
                        mod_Key = SSB;
                        break;
                    case 2:
                        mod_Key = AM;
                        break;
                    case 3:
                        mod_Key = FM;
                        break;
                    case 4:
                        mod_Key = AUTO;
                        break;
                    default:
                        mod_Key = SSB;
                        break;
                }
                if(mod_Key == AUTO)                   // если выбран автоматический режим (AUTO), то ...
                { 
                    band_mod = 0;                // band_mod обнуляем (т.е. вид демодуляции вручную не меняли)
                    lcd.setCursor(0, 1);         // координаты на экране для надписи AUTO 
                    lcd.print("AUTO");           // отображаем выбранный режим
                    delay(1000);                 // Задержка 1 с для прочтения "AUTO" перед переходом в ражим автоматического выбора демодулятора               
                }
                if(count_mode > 4)                  // ограничиваем количество режимов до 4-х
                { 
                    count_mode = 1;
                }  
            }                                   // окончание обработчика нажатия кнопки MOD       

    // --------------------------------- Обработка нажатия кнопки AMP / АТТ ---------------------------------                    
            if(Pressed_Key == 2)                      //если нажата кнопка 3 (AMP/АТТ), то ... 
            { 
                count_regime ++;                // увеличиваем значение переменной count_regime на единицу
                switch (count_regime) {
                    case 1:
                        regime = OFF;
                        break;
                    case 2:
                        regime = AMP_ON;
                        break;
                    case 3:
                        regime = ATT_OFF;
                        break;
                    case 4:
                        regime = ATT_ON;
                        break;
                    default:
                        regime = OFF;
                        break;
                    }
                                
                if(count_regime > 4)           //ограничим количество режимов до 4-х ...
                    { 
                        count_regime = 1;
                        regime = OFF;              //путем присвоения переменной regim единицы, когда она станет больше 4-х
                    } 
                set_regime(); 
            }         
                   
    // --------------------------------- Обработка нажатия кнопки STEP + ---------------------------------
            if(Pressed_Key == 3)                    // если нажата кнопка 3 (STEP "+" ), то ...                     
            { 
                step++;                      // увеличиваем переменную step на единицу
                set_step();                  // обращаемся к функции set_step для установки соответствующего шага перестройки частоты          
                if(step>8)                  // ограничим количество значений, которые может принять step: если step больше 8-ми...
                { 
                    step=8;                  // присваиваем переменной step значение "8"
                    set_step();              // обращаемся к функции set_step для установки соответствующего шага перестройки частоты
                } 
            } 

    // --------------------------------- Обработка нажатия кнопки STEP - ---------------------------------
            if(Pressed_Key == 4)                //если нажата кнопка 4 (STEP "-" ), то ...                     
            { 
                step--;                      // уменьшаем переменную step на единицу
                set_step();                  // обращаемся к функции set_step для установки соответствующего шага перестройки частоты       
                if(step<1)               // ограничим количество значений, которые может принять step: если step меньше единицы ...
                { 
                    step=1;                  // присваиваем переменной step значение "1"
                    set_step();              // обращаемся к функции set_step для установки соответствующего шага перестройки частоты
                } 
            }                                 
            else 
            {                            
                // Если Pressed_Key = 0, то ни одна кнопка не нажата (состояние покоя)
            }
        }
    }
// ---------BAND ----- Границы диапазонов ---------
// ДВ (0,15 - 0,285 МГц)
    if (F_display >= 150000ULL && F_display <= 285000ULL)
    {
        band = 1;
        lcd.setCursor(0, 0);
        lcd.print("LW  ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;  
            mod_Auto = 2;
            set_mod_Auto();
        }
    }
    else if (F_display >= 525000ULL && F_display <= 1605000ULL)   // СВ (0,525 - 1.605 МГц)     
    {
        band = 2;
        lcd.setCursor(0, 0);
        lcd.print("MW  ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }       
    } 
    else if (F_display >= 1810000ULL && F_display <= 2000000ULL)  // 160-метровый (1,81 - 2 МГц)         
    {
        band = 3;
        lcd.setCursor(0, 0);
        lcd.print("160m");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 1;
            set_mod_Auto();
        }
    }
    else if (F_display >= 2300000ULL && F_display <= 2495000ULL)  // 120-метровый (2,3 - 2,495 МГц)         
    {
        band = 4;
        lcd.setCursor(0, 0);
        lcd.print("120m");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }     
    }
    else if (F_display >= 3200000ULL && F_display <= 3400000ULL) // 90-метровый (3,2 - 3,4 МГц)         
    {
        band = 5;
        lcd.setCursor(0, 0);
        lcd.print("90m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }        
    }
    else if (F_display >= 3500000ULL && F_display <= 3800000ULL)  // 80-метровый (3,5 - 3,8 МГц)         
    {
        band = 6;
        lcd.setCursor(0, 0);
        lcd.print("80m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 1;
            set_mod_Auto();
        }        
    }
    else if (F_display >= 3900000ULL && F_display <= 4000000ULL)  // 75-метровый (3,9 - 4,0 МГц)         
    {
        band = 7;
        lcd.setCursor(0, 0);
        lcd.print("75m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }        
    }
    else if (F_display >= 4750000ULL && F_display <= 5060000ULL)  // 60-метровый (4,75 - 5,06 МГц)         
    {
        band = 8;
        lcd.setCursor(0, 0);
        lcd.print("60m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }         
    }
    else if (F_display >= 5850000ULL && F_display <= 6350000ULL)  // 49-метровый (5,85 - 6,35 МГц)         
    {
        band = 9;
        lcd.setCursor(0, 0);
        lcd.print("49m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }      
    }  
    else if (F_display >= 7200000ULL && F_display <= 7500000ULL)  // 41-метровый (7,2 - 7,5 МГц)         
    {
        band = 10;
        lcd.setCursor(0, 0);
        lcd.print("41m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }
    }                
    else if (F_display >= 7000000ULL && F_display <= 7200000ULL)  // 40-метровый (7 - 7,2 МГц)         
    {
        band = 11;
        lcd.setCursor(0, 0);
        lcd.print("40m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 1;
            set_mod_Auto();
        }      
    }     
    else if (F_display >= 9400000ULL && F_display <= 9990000ULL)  // 31-метровый (9,4 - 9,99 МГц)         
    {
        band = 12;
        lcd.setCursor(0, 0);
        lcd.print("31m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }                 
    } 
    else if (F_display >= 10100000ULL && F_display <= 10150000ULL)  // 30-метровый (только телеграф 10,1 - 10,15 МГц)         
    {
        band = 13;
        lcd.setCursor(0, 0);
        lcd.print("30m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 1;
            set_mod_Auto();
        }         
    }            
    else if (F_display >= 11600000ULL && F_display <= 12100000ULL)  // 25-метровый (11,6 - 12,1 МГц)         
    {
        band = 14;
        lcd.setCursor(0, 0);
        lcd.print("25m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }         
    }  
    else if (F_display >= 13500000ULL && F_display <= 13870000ULL)  // 22-метровый (13,5 - 13,87 МГц)         
    {
        band = 15;
        lcd.setCursor(0, 0);
        lcd.print("22m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }     
    }
    else if (F_display >= 14000000ULL && F_display <= 14350000ULL)  // 20-метровый (14 - 14,35 МГц)         
    {
        band = 16;
        lcd.setCursor(0, 0);
        lcd.print("20m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 1;
            set_mod_Auto();
        }      
    }         
    else if (F_display >= 15100000ULL && F_display <= 15600000ULL)  // 19-метровый (15,1 - 15,6 МГц)         
    {
        band = 17;
        lcd.setCursor(0, 0);
        lcd.print("19m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }         
    }
    else if (F_display >= 18068000ULL && F_display <= 18168000ULL)  // 17-метровый (18,068 - 18,168 МГц)         
    {
        band = 18;
        lcd.setCursor(0, 0);
        lcd.print("17m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 1;
            set_mod_Auto();
        }        
    }         
    else if (F_display >= 17550000ULL && F_display <= 18050000ULL)  // 16-метровый (17,55 - 18,05 МГц)         
    {
        band = 19;
        lcd.setCursor(0, 0);
        lcd.print("16m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }       
    }
    else if (F_display >= 18900000ULL && F_display <= 19020000ULL)  // 15-метровый (18,9 - 19,02 МГц)         
    {
        band = 20;
        lcd.setCursor(0, 0);
        lcd.print("15m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }         
    }                                                   
    else if (F_display >= 21000000ULL && F_display <= 21450000ULL)  // 15-метровый (21 - 21,45 МГц)         
    {
        band = 21;
        lcd.setCursor(0, 0);
        lcd.print("15m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 1;
            set_mod_Auto();
        }        
    }
    else if (F_display >= 21450000ULL && F_display <= 21850000ULL)  // 13-метровый (21,45 - 21,85 МГц)         
    {
        band = 22;
        lcd.setCursor(0, 0);
        lcd.print("13m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }      
    }         
    else if (F_display >= 24890000ULL && F_display <= 25140000ULL)  // 12-метровый (24,89 - 25,14 МГц)         
    {
        band = 23;
        lcd.setCursor(0, 0);
        lcd.print("12m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 1;
            set_mod_Auto();
        }         
    }
    else if (F_display >= 25600000ULL && F_display <= 26100000ULL)  // 11-метровый (25,6 - 26,1 МГц)         
    {
        band = 24;
        lcd.setCursor(0, 0);
        lcd.print("11m ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }        
    }
    else if (F_display >= 26965000ULL && F_display <= 27405000ULL)  // CB (26,965 - 27,405 МГц)         
    {
        band = 25;
        lcd.setCursor(0, 0);
        lcd.print("CB  ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }       
    }                       
    else if (F_display >= 28000000ULL && F_display <= 29700000ULL)  // 10-метровый (28 - 29,7 МГц)         
    {
        band = 26;
        lcd.setCursor(0, 0);
        lcd.print("10m  ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }        
    }
    else if (F_display >= 65900000ULL && F_display <= 74000000ULL)  // УКВ-1 (41 - 68 МГц)         
    {
        band = 27;
        lcd.setCursor(0, 0);
        lcd.print("UHF1");
        
        if (band_mod != band) // мы в новом диапазоне?
            {
            band_mod = band;
            mod_Auto = 3;
            set_mod_Auto();
        }       
    }
    else if (F_display >= 87500000ULL && F_display <= 108000000ULL)  // УКВ-2 (87.5 - 108 МГц)         
    {
        band = 28;
        lcd.setCursor(0, 0);
        lcd.print("UHF2");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 3;
            set_mod_Auto();
        }     
    }
    else if (F_display >= 118000000ULL && F_display <= 137000000ULL)  // АВИА (118 - 137 МГц)         
    {
        band = 29;
        lcd.setCursor(0, 0);
        lcd.print("AVIA");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }                   
    }
    else if (F_display >= 144000000ULL && F_display <= 146000000ULL)  // 2 - метровый (144 - 146 МГц)         
    {
        band = 30;
        lcd.setCursor(0, 0);
        lcd.print("2m  ");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 2;
            set_mod_Auto();
        }           
    }                  
    else // Если за границами диапазонов - очистка экрана
    {         
        band = 31;
        lcd.setCursor(0, 0);
        lcd.print("Beyond!");
        
        if (band_mod != band) // мы в новом диапазоне?
        {
            band_mod = band;
            mod_Auto = 0;
            set_mod_Auto();      
        }      
    }
    if (changed_mod)
    {
        set_mod_Key(); 
    }
  
}// Окончание основного цикла

int GetPressed_Key() 
{                                  // Функция определения номера нажатой кнопки с антидребезгом
    static int   count;                // Счетчик
    static int   oldPressed_Key;       // Переменная для хранения предыдущего значения состояния кнопок
    static int   innerPressed_Key;     // Переменная для хранения нового значения нажатой кнопки  
                                     // Здесь уже не можем использовать значение АЦП, так как оно постоянно меняется в силу погрешности
    int actualPressed_Key = GetButtonNumberByValue(analogRead(pinIn));  // Преобразовываем его в номер кнопки, тем самым убирая погрешность  

    if (innerPressed_Key != actualPressed_Key) 
    {  // Пришло значение отличное от предыдущего
        count = 0;                                  // Все обнуляем и начинаем считать заново
        innerPressed_Key = actualPressed_Key;       // Запоминаем новое значение
    }
    else 
    {
        count += 1;                                 // Увеличиваем счетчик
    }

    if ((count >= 20) && (actualPressed_Key != oldPressed_Key)) 
    {
        oldPressed_Key = actualPressed_Key;         // Запоминаем новое значение
    }
    return oldPressed_Key;
}

int GetButtonNumberByValue(int value) {         // Новая функция по преобразованию кода нажатой кнопки в её номер
    int values[5] = {0, 513, 615, 769, 1023};
    int error     = 15;                           // Величина отклонения от значений - погрешность
    for (int i = 0; i <= 4; i++) {
    // Если значение в заданном диапазоне values[i]+/-error - считаем, что кнопка определена
        if (value <= values[i] + error && value >= values[i] - error) return i;
    }
    return -1;                              // Значение не принадлежит заданному диапазону
}
